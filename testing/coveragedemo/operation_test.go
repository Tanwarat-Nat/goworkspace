package coneragrdemo

import (
	"math"
	"testing"
)

func TestBasicOperation(t *testing.T) {
	x := operation(1, 2, '+')
	if x != 3 {
		t.Errorf("operation(%f,%f, +) = %f. Wantd: %f", 1.0, 2.0, x, 3.0)
	}
	x = operation(1, 2, '-')
	if x != -1 {
		t.Errorf("operation(%f,%f, -) = %f. Wantd: %f", 1.0, 2.0, x, -1.0)
	}
	x = operation(1, 2, '*')
	if x != 2 {
		t.Errorf("operation(%f,%f, *) = %f. Wantd: %f", 1.0, 2.0, x, 2.0)
	}
	// การหารจะยากเพราะมีเรื่อง float compare เข้ามาเกี่ยวข้องด้วย
	x = operation(1.0, 3.0, '/')
	epsilon := math.Nextafter(1.0, 2.0) - 1.0
	if math.Abs(x-(1.0/2.0)) > epsilon { //ถ้าลบกันแล้วค่าความต่างมากกว่า epsilon มันผิดพลาดละ
		t.Errorf("operation(%f,%f, /) = %f. Wantd: %f", 1.0, 3.0, x, 0.3333)
	} // ถ้าลบกันแล้วมันมากกว่าค่าที่เรายอมรับได้ วิธีทำให้เรากำหนดค่าที่เล็กที่สุดที่โปรแกรมสามารถแสดงได้
	// epsilon เราต้องสร้างขึ้นมาเอง6
}

/*
วิธีนี้มันลูกทุ่งมากเกินไป
การหารจะยากเพราะมีเรื่อง float compare เข้ามาเกี่ยวข้องด้วย
สิ่งที่ได้ 0.333333 สิ่งที่ต้องการ 0.333300 มันต่างกัน 0.000033
ถึงมันจะสร้าง cover profile แต่เทสมันก็เฟล เทสไม่ถูก ถ้าเราจะเทสในเคสทำนองนี้
จะทำยังไง วิธีง่ายๆเราสามารถ compare แบบเอามาลบกันได้ เพราะเราต้องการเช็คว่า 0.33
ดังนั้นเราสามารถบอกว่า ถ้า x - 0.33 แล้วทั้งหมดนี้เราก็จะได้ 0.00333333... ไปเรื่อยๆ
ดังนั้นเราก้จะมาเช็คว่า ไอ้ตัวนี้ 0.0033333333..  มันมีค่า error มากกว่าค่าที่เรารับได้
ค่าที่เราสามารถรับได้มันก้คือ 0.0033333300 ดังนั้นเราก็สามารถบอกว่า ถ้าค่าที่ result มัน
return ออกมามากกว่าค่าาที่เรารับได้ 0.0033333300 ค่าที่เรารับได้ก็คือความถูกต้อง

x = operation(1.0, 3.0, '/')
	if (x - 0.33) > 0.0034 { // 0.0033333333.. > 0.0033333300
		t.Errorf("operation(%f,%f, /) = %f. Wantd: %f", 1.0, 3.0, x, 0.3333)
	}


เรามาใช้ implementation ที่ simple กว่า การหารอาจใช้สูตรพิสดารได้เพื่อการหารที่รวดเร็วขึ้น
เช่นเราไปหาร big number ต่างๆแล้วเราไม่ใช้การหารแบบธรรมดา
แต่ว่าในส่วนของการเทส ถ้าเราต้องการเทส input จำนวนเล็กๆ เราก็สามารถใช้ simple implementation ได้



*/
